apply plugin: "com.android.model.application"

model {
  android {
    compileSdkVersion 25
    buildToolsVersion "25.0.3"
    
    defaultConfig {
      applicationId "org.kinloch.colin.abstract_art"
      minSdkVersion.apiLevel 21
      targetSdkVersion.apiLevel 25
      versionCode 1
      versionName "1.0"


      buildConfigFields {
          create() {
              type "int"
              name "VALUE"
              value "1"
          }
      }
    }
    
    buildTypes {
      debug {
        ndk.with {
          debuggable = true
        }
      }
      release {
        minifyEnabled false
        //proguardFiles.add(file("proguard-rules.pro"))
        proguardFiles.add(file("proguard-android.txt"))
      }
    }
    
    productFlavors {
      create("armeabi") {
        ndk.abiFilters.add("armeabi")
      }
      create("arm64") {
        ndk.abiFilters.add("arm64-v8a")
      }
    }
    
    sources {
      main {
        java {
          source {
            srcDirs = ["src/main/java"]
          }
        }
        jniLibs {
          dependencies {
            library "abstract_art"
          }
        }
      }
    }
  }
  
  repositories {
    libs(PrebuiltLibraries) {
      vr_music {
        binaries.withType(SharedLibraryBinary) {
          // TODO: Why does targetPlatforms contain every platform?
          def pN = targetPlatform.getName()
          def platforms = [/*"armeabi", */"arm64-v8a"]
          // TODO: Generate multiple versions [arm-linux-androideabi, armv7-linux-androideabi, aarch64-linux-android]
          if (platforms.contains(pN)) {
            sharedLibraryFile = file("../../target/${getRustTarget(pN)}/debug/libs/${pN}/libvr_music.so")
          }
        }
      }
    }
  }
}

String getArch(String buildType) {
  return buildType.replaceAll(/(Debug|Release)/, "")
}

boolean isDebug(String buildType) {
  return buildType.contains("Debug")
}

String getTargetDir(boolean debug, String arch) {
  def basePath = project.rootDir.getParentFile().absolutePath
  return basePath + "/target/" + getRustTarget(arch) + "/" + (debug ? "debug" : "release")
}

String getApkPath(boolean debug, String arch) {
  return getTargetDir(debug, arch) + "/muzak.apk"
}

def getJniLibsPath(boolean debug, String arch) {
  return [
    getTargetDir(debug, arch) + "/libs",
    "../libs",
    "../../libs"
  ]
}

String getRustTarget(String arch) {
  switch (arch.toLowerCase()) {
    case "arm" : return "arm-linux-androideabi"
    case "armeabi" : return "arm-linux-androideabi"
    case "armv7" : return "armv7-linux-androideabi"
    case "armeabi-v7a" : return "armv7-linux-androideabi"
    case "arm64" : return "aarch64-linux-android"
    case "arm64-v8a" : return "aarch64-linux-android"
    case "mips" : return "mipsel-linux-android"
    case "mips64" : return "mips64el-linux-android"
    //case "x86" : return "x86"
    //case "x86_64" : return "x86_64"
    //default: return ""
    default: throw new GradleException("Invalid target architecture " + arch)
  }
}

String getNDKAbi(String arch) {
  switch (arch.toLowerCase()) {
    case "arm" : return "armeabi"
    case "armv7" : return "armeabi-v7a"
    case "arm64" : return "arm64-v8a"
    case "x86" : return "x86"
    default: throw new GradleException("Invalid target architecture " + arch)
  }
}
